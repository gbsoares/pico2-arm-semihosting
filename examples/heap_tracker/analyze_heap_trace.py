#!/usr/bin/env python3
"""
Heap Trace Analyzer

This script analyzes the binary heap trace files generated by the heap_tracker target.
It reads the binary records and presents them in a human-readable format.
"""

import struct
import sys
from datetime import datetime

# Operation types (must match the C enum)
HEAP_OP_INIT = 0
HEAP_OP_MALLOC = 1
HEAP_OP_FREE = 2
HEAP_OP_REALLOC = 3

operation_names = {
    HEAP_OP_INIT: "INIT",
    HEAP_OP_MALLOC: "MALLOC",
    HEAP_OP_FREE: "FREE",
    HEAP_OP_REALLOC: "REALLOC"
}

def analyze_heap_trace(filename):
    """Analyze a binary heap trace file."""
    try:
        with open(filename, 'rb') as f:
            print(f"Analyzing heap trace file: {filename}")
            print("=" * 60)
            
            record_count = 0
            malloc_count = 0
            free_count = 0
            realloc_count = 0
            total_allocated = 0
            current_allocated = 0
            peak_allocated = 0
            
            # Track active allocations
            active_allocations = {}
            
            while True:
                # Read each record: operation(4) + timestamp(8) + arg1(4) + arg2(4) + arg3(4) + padding(4) = 28 bytes
                record_data = f.read(28)
                if len(record_data) < 28:
                    break
                
                operation, timestamp_us, arg1, arg2, arg3, padding = struct.unpack('<IQIIII', record_data)
                
                if operation not in operation_names:
                    print(f"Warning: Unknown operation type {operation}")
                    break
                
                record_count += 1
                
                # Convert timestamp to seconds for readability
                timestamp_sec = timestamp_us / 1_000_000.0
                
                print(f"[{record_count:4d}] {timestamp_sec:10.6f}s {operation_names[operation]:8s}", end=" ")
                
                if operation == HEAP_OP_INIT:
                    # init: arg1=initial_heap_size, arg2=unused, arg3=unused
                    initial_heap_size = arg1
                    print(f"initial_heap_size={initial_heap_size}")
                    
                elif operation == HEAP_OP_MALLOC:
                    # malloc: arg1=size, arg2=result_ptr, arg3=unused
                    size = arg1
                    result_ptr = arg2
                    
                    malloc_count += 1
                    total_allocated += size
                    current_allocated += size
                    peak_allocated = max(peak_allocated, current_allocated)
                    
                    if result_ptr != 0:  # NULL pointer check
                        active_allocations[result_ptr] = size
                    
                    print(f"size={size:6d} bytes -> ptr=0x{result_ptr:08x}")
                    
                elif operation == HEAP_OP_FREE:
                    # free: arg1=ptr, arg2=unused, arg3=unused
                    ptr = arg1
                    
                    free_count += 1
                    
                    if ptr in active_allocations:
                        freed_size = active_allocations[ptr]
                        current_allocated -= freed_size
                        del active_allocations[ptr]
                        print(f"ptr=0x{ptr:08x} (freed {freed_size} bytes)")
                    else:
                        print(f"ptr=0x{ptr:08x} (unknown allocation or NULL)")
                    
                elif operation == HEAP_OP_REALLOC:
                    # realloc: arg1=old_ptr, arg2=new_size, arg3=result_ptr
                    old_ptr = arg1
                    new_size = arg2
                    result_ptr = arg3
                    
                    realloc_count += 1
                    
                    # Handle old allocation
                    old_size = 0
                    if old_ptr in active_allocations:
                        old_size = active_allocations[old_ptr]
                        current_allocated -= old_size
                        del active_allocations[old_ptr]
                    
                    # Handle new allocation
                    if result_ptr != 0 and new_size > 0:
                        current_allocated += new_size
                        total_allocated += new_size
                        peak_allocated = max(peak_allocated, current_allocated)
                        active_allocations[result_ptr] = new_size
                    
                    print(f"0x{old_ptr:08x}({old_size}) -> {new_size} bytes @ 0x{result_ptr:08x}")
            
            print("=" * 60)
            print(f"Summary:")
            print(f"  Total records: {record_count}")
            print(f"  malloc calls:  {malloc_count}")
            print(f"  free calls:    {free_count}")
            print(f"  realloc calls: {realloc_count}")
            print(f"  Total allocated: {total_allocated} bytes")
            print(f"  Peak allocated:  {peak_allocated} bytes") 
            print(f"  Current allocated: {current_allocated} bytes")
            print(f"  Active allocations: {len(active_allocations)}")
            
            if active_allocations:
                print(f"\nPotential memory leaks:")
                for ptr, size in active_allocations.items():
                    print(f"  0x{ptr:08x}: {size} bytes")
    
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        return False
    except Exception as e:
        print(f"Error analyzing file: {e}")
        return False
    
    return True

def main():
    if len(sys.argv) != 2:
        print("Usage: python3 analyze_heap_trace.py <heap_trace.bin>")
        print("       Analyzes binary heap trace files generated by heap_tracker")
        sys.exit(1)
    
    filename = sys.argv[1]
    if not analyze_heap_trace(filename):
        sys.exit(1)

if __name__ == "__main__":
    main()